
# TPAMI 2024：Frequency-aware Feature Fusion for Dense Image Prediction

import torch
import torch.nn as nn
import torch.nn.functional as F

try:
    from mmcv.ops.carafe import normal_init, xavier_init, carafe
except ImportError:
    pass
from torch.utils.checkpoint import checkpoint
import warnings
import numpy as np

__all__ = ['FreqFusion']

# xavier_init 和 normal_init
# 这两个函数用于初始化卷积层的权重。xavier_init 使用 Xavier 初始化方法，而 normal_init 使用正态分布初始化权重。

def xavier_init(module: nn.Module,
                gain: float = 1,
                bias: float = 0,
                distribution: str = 'normal') -> None:
    assert distribution in ['uniform', 'normal']
    if hasattr(module, 'weight') and module.weight is not None:
        if distribution == 'uniform':
            nn.init.xavier_uniform_(module.weight, gain=gain)
        else:
            nn.init.xavier_normal_(module.weight, gain=gain)
    if hasattr(module, 'bias') and module.bias is not None:
        nn.init.constant_(module.bias, bias)

# carafe 函数是一个卷积操作，执行了一个基于掩码的插值过程，用于特征图的重采样。
# 在此处，它通过 normed_mask（标准化的掩码）对输入特征图 x 进行变换，输出新的特征图。
def carafe(x, normed_mask, kernel_size, group=1, up=1):
    b, c, h, w = x.shape
    _, m_c, m_h, m_w = normed_mask.shape
    # print('x', x.shape)
    # print('normed_mask', normed_mask.shape)
    # assert m_c == kernel_size ** 2 * up ** 2
    # print(f"m_h: {m_h}, up: {up}, h: {h}")
    assert m_h == up * h
    assert m_w == up * w
    pad = kernel_size // 2
    # print(pad)
    pad_x = F.pad(x, pad=[pad] * 4, mode='reflect')
    # print(pad_x.shape)
    unfold_x = F.unfold(pad_x, kernel_size=(kernel_size, kernel_size), stride=1, padding=0)
    # unfold_x = unfold_x.reshape(b, c, 1, kernel_size, kernel_size, h, w).repeat(1, 1, up ** 2, 1, 1, 1, 1)
    unfold_x = unfold_x.reshape(b, c * kernel_size * kernel_size, h, w)
    unfold_x = F.interpolate(unfold_x, scale_factor=up, mode='nearest')
    # normed_mask = normed_mask.reshape(b, 1, up ** 2, kernel_size, kernel_size, h, w)
    unfold_x = unfold_x.reshape(b, c, kernel_size * kernel_size, m_h, m_w)
    normed_mask = normed_mask.reshape(b, 1, kernel_size * kernel_size, m_h, m_w)
    res = unfold_x * normed_mask
    # test
    # res[:, :, 0] = 1
    # res[:, :, 1] = 2
    # res[:, :, 2] = 3
    # res[:, :, 3] = 4
    res = res.sum(dim=2).reshape(b, c, m_h, m_w)
    # res = F.pixel_shuffle(res, up)
    # print(res.shape)
    # print(res)
    return res

def normal_init(module, mean=0, std=1, bias=0):
    if hasattr(module, 'weight') and module.weight is not None:
        nn.init.normal_(module.weight, mean, std)
    if hasattr(module, 'bias') and module.bias is not None:
        nn.init.constant_(module.bias, bias)

# 用于调整图像尺寸，支持多种插值方式（如最近邻插值、双线性插值等）。
def resize(input,
           size=None,
           scale_factor=None,
           mode='nearest',
           align_corners=None,
           warning=True):
    if warning:
        if size is not None and align_corners:
            input_h, input_w = tuple(int(x) for x in input.shape[2:])
            output_h, output_w = tuple(int(x) for x in size)
            if output_h > input_h or output_w > input_w:
                if ((output_h > 1 and output_w > 1 and input_h > 1
                     and input_w > 1) and (output_h - 1) % (input_h - 1)
                        and (output_w - 1) % (input_w - 1)):
                    warnings.warn(
                        f'When align_corners={align_corners}, '
                        'the output would more aligned if '
                        f'input size {(input_h, input_w)} is `x+1` and '
                        f'out size {(output_h, output_w)} is `nx+1`')
    return F.interpolate(input, size, scale_factor, mode, align_corners)

# 生成一个二维的 Hamming 窗（Hamming window）。Hamming窗用于对图像进行频域处理时减小边缘效应。
def hamming2D(M, N):
    """
    生成二维Hamming窗

    参数：
    - M：窗口的行数
    - N：窗口的列数

    返回：
    - 二维Hamming窗
    """
    # 生成水平和垂直方向上的Hamming窗
    # hamming_x = np.blackman(M)
    # hamming_x = np.kaiser(M)
    hamming_x = np.hamming(M)
    hamming_y = np.hamming(N)
    # 通过外积生成二维Hamming窗
    hamming_2d = np.outer(hamming_x, hamming_y)
    return hamming_2d

# FreqFusion 是实现频率感知特征融合的核心模块。它的初始化和前向传递过程包含了多个组件和操作，
# 目的是将高分辨率（HR）和低分辨率（LR）图像的特征融合，从而改善图像重建的效果。
class FreqFusion(nn.Module):
    def __init__(self, channels, scale_factor=1, lowpass_kernel=5, highpass_kernel=3, up_group=1, encoder_kernel=3, encoder_dilation=1, compressed_channels=64, align_corners=False, upsample_mode='nearest', feature_resample=False, feature_resample_group=4, comp_feat_upsample=True, use_high_pass=True, use_low_pass=True, hr_residual=True, semi_conv=True, feature_resample_norm=True, **kwargs):
        super().__init__()
        hr_channels, lr_channels = channels
        self.scale_factor = scale_factor
        self.lowpass_kernel = lowpass_kernel
        self.highpass_kernel = highpass_kernel
        self.up_group = up_group
        self.encoder_kernel = encoder_kernel
        self.encoder_dilation = encoder_dilation
        self.compressed_channels = (hr_channels + lr_channels) // 8
        # 1x1 卷积层，将高分辨率特征压缩到压缩通道数
        self.hr_channel_compressor = nn.Conv2d(hr_channels, self.compressed_channels, 1)
        # 1x1 卷积层，将低分辨率特征压缩到压缩通道数
        self.lr_channel_compressor = nn.Conv2d(lr_channels, self.compressed_channels, 1)
        # 卷积层，作为 ALPF 生成器，用于生成低通特征相关的掩码
        self.content_encoder = nn.Conv2d(
            self.compressed_channels,
            lowpass_kernel ** 2 * self.up_group * self.scale_factor * self.scale_factor,
            self.encoder_kernel,
            padding=int((self.encoder_kernel - 1) * self.encoder_dilation / 2),
            dilation=self.encoder_dilation,
            groups=1)
        self.align_corners = align_corners
        self.upsample_mode = upsample_mode
        self.hr_residual = hr_residual
        self.use_low_pass = use_low_pass
        self.feature_resample = feature_resample
        self.comp_feat_upsample = comp_feat_upsample
        # 卷积层，作为 AHPF 生成器，用于生成高通特征相关的掩码
        self.content_encoder2 = nn.Conv2d(
            self.compressed_channels,
            highpass_kernel ** 2 * self.up_group * self.scale_factor * self.scale_factor,
            self.encoder_kernel,
            padding=int((self.encoder_kernel - 1) * self.encoder_dilation / 2),
            dilation=self.encoder_dilation,
            groups=1)
        lowpass_pad = 0
        highpass_pad = 0

        self.register_buffer('hamming_lowpass', torch.FloatTensor(
            hamming2D(lowpass_kernel + 2 * lowpass_pad, lowpass_kernel + 2 * lowpass_pad))[None, None,])
        self.register_buffer('hamming_highpass', torch.FloatTensor(
            hamming2D(highpass_kernel + 2 * highpass_pad, highpass_kernel + 2 * highpass_pad))[None, None,])

        # 初始化权重
        self.init_weights()

    # 对 FreqFusion 模块中的卷积层进行初始化，使用 xavier_init 初始化权重，normal_init 初始化卷积层。
    def init_weights(self):
        for m in self.modules():
            # print(m)
            if isinstance(m, nn.Conv2d):
                xavier_init(m, distribution='uniform')
        normal_init(self.content_encoder, std=0.001)
        normal_init(self.content_encoder2, std=0.001)

    # 该函数对掩码进行标准化，并对 hamming 窗进行加权处理。掩码经过 softmax 归一化后，根据 hamming 窗调整其值。
    def kernel_normalizer(self, mask, kernel, scale_factor=None, hamming=1):
        if scale_factor is not None:
            mask = F.pixel_shuffle(mask, self.scale_factor)
        n, mask_c, h, w = mask.size()
        mask_channel = int(mask_c / float(kernel ** 2))
        # mask = mask.view(n, mask_channel, -1, h, w)
        # mask = F.softmax(mask, dim=2, dtype=mask.dtype)
        # mask = mask.view(n, mask_c, h, w).contiguous()

        mask = mask.view(n, mask_channel, -1, h, w)
        mask = F.softmax(mask, dim=2, dtype=mask.dtype)
        mask = mask.view(n, mask_channel, kernel, kernel, h, w)
        mask = mask.permute(0, 1, 4, 5, 2, 3).view(n, -1, kernel, kernel)
        # mask = F.pad(mask, pad=[padding] * 4, mode=self.padding_mode) # kernel + 2 * padding
        mask = mask * hamming
        mask /= mask.sum(dim=(-1, -2), keepdims=True)
        # print(hamming)
        # print(mask.shape)
        mask = mask.view(n, mask_channel, h, w, -1)
        mask = mask.permute(0, 1, 4, 2, 3).view(n, -1, h, w).contiguous()
        return mask

    # forward 函数接收高分辨率和低分辨率特征图并调用 _forward 进行特征融合。
    def forward(self, x, use_checkpoint=False):
        # print(x)
        hr_feat, lr_feat = x
        if use_checkpoint:
            return checkpoint(self._forward, hr_feat, lr_feat)
        else:
            return self._forward(hr_feat, lr_feat)

    def forward(self, x, use_checkpoint=False):
        hr_feat, lr_feat = x
        if use_checkpoint:
            return checkpoint(self._forward, hr_feat, lr_feat)
        else:
            return self._forward(hr_feat, lr_feat)
    def _forward(self, hr_feat, lr_feat):
        compressed_hr_feat = self.hr_channel_compressor(hr_feat)
        compressed_lr_feat = self.lr_channel_compressor(lr_feat)

        mask_hr_hr_feat = self.content_encoder2(compressed_hr_feat)  # 从hr_feat得到初始高通滤波特征
        mask_hr_init = self.kernel_normalizer(mask_hr_hr_feat, self.highpass_kernel,
                                              hamming=self.hamming_highpass)  # kernel归一化得到初始高通滤波

        compressed_hr_feat = compressed_hr_feat + compressed_hr_feat - carafe(compressed_hr_feat, mask_hr_init,
                                                                              self.highpass_kernel, self.up_group,
                                                                              1)  # 利用初始高通滤波对压缩hr_feat的高频增强 （x-x的低通结果=x的高通结果）

        mask_lr_hr_feat = self.content_encoder(compressed_hr_feat)  # 从hr_feat得到初始低通滤波特征
        mask_lr_init = self.kernel_normalizer(mask_lr_hr_feat, self.lowpass_kernel,
                                              hamming=self.hamming_lowpass)  # kernel归一化得到初始低通滤波

        mask_lr_lr_feat_lr = self.content_encoder(compressed_lr_feat)  # 从lr_feat得到另一部分初始低通滤波特征
        mask_lr_lr_feat = F.interpolate(  # 利用初始低通滤波对另一部分初始低通滤波特征上采样
            carafe(mask_lr_lr_feat_lr, mask_lr_init, self.lowpass_kernel, self.up_group, 2),
            size=compressed_hr_feat.shape[-2:], mode='nearest')
        mask_lr = mask_lr_hr_feat + mask_lr_lr_feat  # 将两部分初始低通滤波特征合在一起

        mask_lr_init = self.kernel_normalizer(mask_lr, self.lowpass_kernel,
                                              hamming=self.hamming_lowpass)  # 得到初步融合的初始低通滤波
        mask_hr_lr_feat = F.interpolate(  # 使用初始低通滤波对lr_feat处理，分辨率得到提高
                carafe(self.content_encoder2(compressed_lr_feat), mask_lr_init, self.lowpass_kernel, self.up_group, 2),
            size=compressed_hr_feat.shape[-2:], mode='nearest')
        mask_hr = mask_hr_hr_feat + mask_hr_lr_feat  # 最终高通滤波特征

        mask_lr = self.kernel_normalizer(mask_lr, self.lowpass_kernel, hamming=self.hamming_lowpass)
        lr_feat = carafe(lr_feat, mask_lr.to(compressed_hr_feat.dtype), self.lowpass_kernel, self.up_group, 2)

        mask_hr = self.kernel_normalizer(mask_hr, self.highpass_kernel, hamming=self.hamming_highpass)
        if self.hr_residual:
            hr_feat_hf = hr_feat - carafe(hr_feat, mask_hr.to(compressed_hr_feat.dtype), self.highpass_kernel,
                                    self.up_group, 1)
            hr_feat = hr_feat_hf + hr_feat
        else:
            hr_feat = hr_feat_hf

        # 返回低通掩码、高分辨率特征、低分辨率特征、融合后的特征
        # return  mask_lr, hr_feat, lr_feat, hr_feat + lr_feat
        return hr_feat + lr_feat


if __name__ == '__main__':

    hr_feat = torch.randn(1,256,40,40).cuda()
    lr_feat = torch.randn(1,256,20,20).cuda()

    # x = [hr_feat, lr_feat]

    # freq_fusion = FreqFusion(hr_channels=256,lr_channels=256).cuda()
    freq_fusion = FreqFusion(channels=[256, 256]).cuda()

    output = freq_fusion([hr_feat,lr_feat])

    print("hr_feat size:",hr_feat.shape)    # hr_feat size: torch.Size([1, 256, 40, 40])
    print("lr_feat size:",lr_feat.shape)    # lr_feat size: torch.Size([1, 256, 20, 20])

    # print("output size:",output.shape)      # output size: torch.Size([1, 256, 40, 40])
    # print("mask_lr size:",output[0].shape)      # output size: torch.Size([1, 25, 40, 40])
    # print("hr_feat size:",output[1].shape)      # output size: torch.Size([1, 256, 40, 40])
    # print("lr_feat size:",output[2].shape)      # output size: torch.Size([1, 256, 40, 40])
    print("lr_feat + hr_feat size:",output.shape)      # output size: torch.Size([1, 256, 40, 40])


